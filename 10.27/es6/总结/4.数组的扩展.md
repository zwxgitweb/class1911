
数组的方法
1. Array.from()


1. 扩展运算符
>扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列

扩展运算符的应用
1. 复制数组
> 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组
```js
const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
```
2. 合并数组
> 这两种方法都是浅拷贝，使用的时候需要注意
```js
const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]

const a1 = [{ foo: 1 }];
const a2 = [{ bar: 2 }];

const a3 = a1.concat(a2);
const a4 = [...a1, ...a2];

let a = {a: '1'};
let b = {b: '2'};
const a1 = [a, b];
const b1 = [...a1]

a3[0] === a1[0] // true
a4[0] === a1[0] // -
// 用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组
```

3. 与解构赋值结合
> 扩展运算符可以与解构赋值结合起来，用于生成数组
```js
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
```

4. 扩展运算符可以将字符串转为真正的数组
```js
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```


###数组的方法
1. Array.from();

> 将两类对象转为真正的数组：  
1.1 类似数组的对象（array-like object）
>注： 任何有length属性的对象，都可以通过Array.from方法转为数组
```js
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']


Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
```
1.2 可遍历（iterable）的对象(包括 ES6 新增的数据结构 Set 和 Map)
> 部署了 Iterator 接口的数据结构，Array.from都能将其转为数组
```js
// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).filter(p => {
  return p.textContent.length > 100;
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}
```

2. Array.from()的参数
第一个参数： 需要转为数组的对象
第二个参数： 过滤器函数
第三个参数: 在过滤器函数中的this对象
```js
var obj = {
    0: 1,
    1: 2,
    2: 3,
    length: 3
};

let keys = {
    a: 1
}

console.log(Array.from(obj,  function (item) {
    console.log(this.a)
    return this.a + item

}, keys))
```



2. Array.of();
> Array.of方法用于将一组值，转换为数组, 弥补数组构造函数Array()的不足
> 总是返回参数值组成的数组。如果没有参数，就返回一个空数组
```js
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
```

3. array.copyWithin(target, start, end)
> 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组
    target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
    start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
    end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算
```js
console.log([0, 1, 2, 3, 4, 5, 6, 7, 8].copyWithin(0, 3)); // [ 3, 4, 5, 6, 7, 8, 6, 7, 8 ]

console.log([0, 1, 2, 3, 4, 5, 6, 7, 8].copyWithin(0, 3, 5)); // [ 3, 4, 2, 3, 4, 5, 6, 7, 8 ]
```

4. array.find(callback(item, index, arr))
> 用于找出第一个符合条件的数组成员
> 所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员
> 没有找到返回undefined
参数：
    第一个参数：callback
            item：当前元素
            index: 当前下标
            arr: 原数组
    第二个参数：对象
        回调函数中的this对象指向的对象。

```js
function f(v){
  return v > this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26

```

5. array.findIndex(callback(item, index, arr));
> 返回第一个符合条件的数组成员的位置
> 如果所有成员都不符合条件，则返回-1
```
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}) // 2
```

6. array.fill(val, start, end)
> 使用给定值，填充一个数组
        val: 填充值
        start: 开始填充的起始位置
        end:   填充的 结束的位置
```
['a', 'b', 'c'].fill(7, 1, 2); // ['a', 7, 'c']
```

7. array.includes(val, target)
> 表示某个数组是否包含给定的值
参数
    val: 查询的参数
    index: 搜索的起始位置 默认为0
```
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
```

8. 
array.keys(); => 键名的遍历
array.values(); => 键值的遍历
array.entries(); => 键值对的遍历

```js
for (let index of ['a', 'b'].keys()) {
    console.log(index);
}

for (let value of ['a', 'b'].values()) {
    console.log(value);
}

for (let entry of ['a', 'b'].entries()) {
    console.log(entry); // [index, value]
}
```

9. 扁平化
array.flat(扁平层数 = 1); 
> 扁平层数: Infinity
> 原数组有空位，flat()方法会跳过空位
```js
console.log([1, [2, 3]].flat()) // [1, 2, 3]
console.log([1, [2, , 3]].flat()) // [1, 2, 3]
console.log([1, [2, [3]]].flat()); // [1, 2, [3]]
console.log([1, [2, [3]]].flat(2)); // [1, 2, 3]
```
array.flatMap()
>1. 对原数组的每个成员执行一个函数，相当于执行Array.prototype.map()
>2. 然后对返回值组成的数组执行flat()方法
>3. 该方法返回一个新数组，不改变原数组
>4. 只能展开一层数组

```js
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]


// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
[1, 2, 3, 4].flatMap(x => [[x * 2]])
// [[2], [4], [6], [8]]
```


10. 数组空位

> forEach(), filter(), reduce(), every() 和some()都会跳过空位
> map()会跳过空位，但会保留这个值
> join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串
```js
// forEach方法
[,'a'].forEach((x,i) => console.log(i)); // 1

// filter方法
['a',,'b'].filter(x => true) // ['a','b']

// every方法
[,'a'].every(x => x==='a') // true

// reduce方法
[1,,2].reduce((x,y) => x+y) // 3

// some方法
[,'a'].some(x => x !== 'a') // false

// map方法
[,'a'].map(x => 1) // [,1]

// join方法
[,'a',undefined,  ].join('#') // "#a##"

// toString方法
[,'a',undefined,null].toString() // ",a,,"
```
> ES6 则是明确将空位转为undefined
> Array.from方法会将数组的空位，转为undefined
```js
Array.from(['a',,'b'])
// [ "a", undefined, "b" ]
```
> 扩展运算符（...）也会将空位转为undefined
```js
[...['a',,'b']]
// [ "a", undefined, "b" ]
```
> copyWithin()会连空位一起拷贝
```js
[,'a','b',,].copyWithin(2,0) // [,"a",,"a"]
```
> fill()会将空位视为正常的数组位置
```js
new Array(3).fill('a') // ["a","a","a"]
```
> for...of循环也会遍历空位
```js
let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1
```
> entries()、keys()、values()、find()和findIndex()会将空位处理成undefined
```js
// entries()
[...[,'a'].entries()] // [[0,undefined], [1,"a"]]

// keys()
[...[,'a'].keys()] // [0,1]

// values()
[...[,'a'].values()] // [undefined,"a"]

// find()
[,'a'].find(x => true) // undefined

// findIndex()
[,'a'].findIndex(x => true) // 0
```

