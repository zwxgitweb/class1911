Generator - 异步编程解决方法之一
>Generator函数是一个状态机，封装了多个内部状态

执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历对象生成函数，返回遍历器对象，可以依次遍历Generator函数内部的每一个状态

特点
1. function关键字与函数名之间一个星号
2. 函数体内部使用yield（产出）表达式，定义不同的内部状态
```js
    function *hWG() {
        yield 'hello';
        yield 'world';
        return 'ending';
    }

    let item = hWG();
    console.log(item);
    console.log(item.next()); // value: "hello", done: false}
    console.log(item.next()); // {value: "world", done: false}
    console.log(item.next()); // {value: "ending", done: true}
    console.log(item.next()); // {value: undefined, done: true}
```
1. 第一次调用 Generator函数开始运行，知道遇到一个第一个yield表达式为止，next方法返回了一个对象，包裹value(当前yeild表达式的值)，done是属性值为false，说明遍历并没有结束

2. 第二次调用的时候，Generator函数从上一次yield表达式停下的地方，一直执行到下一个yield表达式，next方法返回的对象的value属性就是当前yield的返回值，done属性为false，说明未结束

3. 当return语句执行后(或者没有return页结束了) next方法会返回return的值(没有返回值的函数就undefined的)， done的值为true，说明遍历结束


Generator函数的写法
```js
function * foo(x, y) { ··· }
function *foo(x, y) { ··· }
function* foo(x, y) { ··· }
function*foo(x, y) { ··· }
```

yield表达式
由于Genertor函数返回的遍历器对象，只要调用了next方法才会遍历到下一个内部状态，因此可以看出，yield是一种暂停标志

遍历器对象的next方法的运行逻辑
1. 当遇到yield表达式，就暂停执行后面的操作，返回紧跟yield的值，作为value的属性值

2. 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式
    yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能

3. 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值
如果该函数没有return语句，则返回的对象的value属性值为undefined done：


yield表达式用在另一个表达式之中，就必须放在圆括号里面
```js
function* demo() {
  console.log('Hello' + yield); // SyntaxError
  console.log('Hello' + yield 123); // SyntaxError

  console.log('Hello' + (yield)); // OK
  console.log('Hello' + (yield 123)); // OK
}
```

next方法的参数
yield表达式本身是没有返回值的，或者说返回的是undefined， next方法就可以带一个参数,就会被当做上一个yield表达式的返回值

```js
function* f() {
  for(var i = 0; true; i++) {
    var reset = yield i;
    if(reset) { i = -1; }
  }
}

var g = f();

g.next() // { value: 0, done: false }
g.next() // { value: 1, done: false }
g.next(true) // { value: 0, done: false }
```


for...of循环
> for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法

```js
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
```


Generator.prototype.throw()
Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获

```js
var g = function* () {
  try {
    yield;
  } catch (e) {
    console.log('内部捕获', e);
  }
};

var i = g();
i.next();

try {
  i.throw('a');
  i.throw('b');
} catch (e) {
  console.log('外部捕获', e);
}
// 内部捕获 a
// 外部捕获 b
```
> 遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获

Generator.prototype.return()
Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数

```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

var g = gen();

g.next()        // { value: 1, done: false }
// return方法调用时，不提供参数，则返回值的value属性为undefined
g.return('foo') // { value: "foo", done: true }
g.next()        // { value: undefined, done: true }
```


next()、throw()、return() 的共同点
> next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式


next()是将yield表达式替换成一个值
throw()是将yield表达式替换成一个throw语句
return()是将yield表达式替换成一个return语句

```js
const g = function* (x, y) {
  let result = yield x + y;
  return result;
};

const gen = g(1, 2);
gen.next(); // Object {value: 3, done: false}

gen.next(1); // Object {value: 1, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = 1;

gen.throw(new Error('出错了')); // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成 let result = throw(new Error('出错了'));

gen.return(2); // Object {value: 2, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = return 2;

```


yield* 表达式
> yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数
```js
function* foo() {
  yield 'a';
  yield 'b';
}

function* bar() {
  yield 'x';
  // 手动遍历 foo()
  for (let i of foo()) {
    console.log(i);
  }

  // for..of  => yield* foo();
  yield 'y';
}

for (let v of bar()){
  console.log(v);
}
// x
// a
// b
// y
```

实际上任何数据结构只要有Iterator接口，就会被yield*遍历
```js
let read = (function* () {
  yield 'hello';
  yield* 'hello';
})();

read.next().value // "hello"
read.next().value // "h"
```

Generator 与状态机
Generator 是实现状态机的最佳结构
```js
var ticking = true;
var clock = function() {
  if (ticking)
    console.log('Tick!');
  else
    console.log('Tock!');
  ticking = !ticking;
}
```
clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态
```js
var clock = function* () {
  while (true) {
    console.log('Tick!');
    yield;
    console.log('Tock!');
    yield;
  }
};
```