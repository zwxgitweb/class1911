1. 属性的简洁表示法
```js
let x = 'xxx'
let obj = {
    x,
    say() {
        console.log(this.name)
    }
}
```

2. 属性名的表达式
> 用表达式作为属性名，要将表达式放在方括号之内
```js

let propKey = 'a';
let obj = {
  [propKey]: true,

  // 还可以作为属性名
  ['a' + 'b']: 123,

  // 还可以做为函数名
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj['a' + 'bc'] = 123;
```


3. 属性的可枚举性和遍历
> 可枚举性：对象的每个属性都有一个描述对象，用来控制该属性的行为
> 使用Object.getOwnPropertyDescriptor方法可以获取属性的描述对象
```js
let obj = {
    foo: 'value'
};

let desc = Object.getOwnPropertyDescriptor(obj, 'foo');
{
    configurable: true, // 是否可配置
    enumerable: true, // 是否可枚举
    value: "value", // 值
    writable: true // 是否可写
}
```

四个操作会忽略enumerable为false的属性
1. for...in循环：只遍历对象自身的和继承的可枚举的属性。
2. Object.keys()：返回对象自身的所有可枚举的属性的键名。
3. JSON.stringify()：只串行化对象自身的可枚举的属性。
4. Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性

遍历属性的五种方法
1. for...in
> for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）

2. Object.keys(obj)
> Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名

3. Object.getOwnPropertyNames(obj)
> Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名

4. Object.getOwnPropertySymbols(obj)
> Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名

5. Reflect.ownKeys(obj)
> Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举

以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则:
    首先遍历所有数值键，按照数值升序排列。
    其次遍历所有字符串键，按照加入时间升序排列。
    最后遍历所有 Symbol 键，按照加入时间升序排列。


4. super关键字
> this关键字总是指向函数所在的当前对象
> ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象
    只能用在对象的方法之中，用在其他地方都会报错

```js
const proto = {
  foo: 'hello'
};

const obj = {
  foo: 'world',
  find() {
    return super.foo;
  }
};
// 设置对象的原型
Object.setPrototypeOf(obj, proto);
obj.find() // "hello"
```

5. 对象的扩展运算符
解构赋值
> 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面
> 所有的键和它们的值，都会拷贝到新对象上面
注： 
1. 解构赋值必须是最后一个参数
2. 解构赋值的拷贝是浅拷贝
```js
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

扩展运算符
> 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中
```js
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }

// 数组比较特殊
let foo = { ...['a', 'b', 'c'] };
foo
// {0: "a", 1: "b", 2: "c"}

// 扩展运算符后面是一个空对象，则没有任何效果
{...{}, a: 1}
// { a: 1 }
```