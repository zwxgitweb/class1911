### Proxy
 代理的意思： 表示由它来代理某些操作，可以译为代理器
    其实就是在目标对象之前做了一层拦截，其机制就是对外界的访问进行过滤和改写

创建proxy实例
```
var proxy = new Proxy(target, handler);
```
target: 所要拦截的目标对象
handler: 用来定制拦截行为 (handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target)


Proxy上实例的方法
1. get方法，用于拦截某个属性的读取操作

    get(target, property, proxy实例本身)
        target: 目标对象(obj)
        property: 属性名
        proxy: 实例本身

例子
```js
let obj = {
    k: 'hello'
};

// 创建proxy实例
// 第一个参数： 拦截目标
// 第二个参数： 定制拦截的行为
let proxyO = new Proxy(obj, {
    get(target, property) {
        // 拦截的对象， 当前拦截的属性
        console.log(target, property); // {k: 'hello'}, 'k'
        return 1; // 只返回1
    }
});

console.log(proxyO.k); // {k: 'hello'}, 'k' 1
console.log(proxyO.y); // {k: 'hello'}, 'y' 1

```
>get在继承中做拦截: 当读取继承属性的时候，拦截生效
```js
    // get在继承中做拦截: 当读取继承属性的时候，拦截生效
    let handler = {
        // 接收一个目标对象，与当前拦截的属性
        get(target, property) {
            console.log(target, property);
            return `GET:` + property;
        }
    }
    let proxy = new Proxy({}, handler);

    let o = Object.create(proxy);

    o.a = 1;
    console.log(o.a); // 1
    console.log(o.k); // {} "k"  => GET:K
```
> 第三个参数为: 指向proxy对象
```js
const proxy = new Proxy({}, {
  get: function(target, property, receiver) {
    return receiver;
  }
});

const d = Object.create(proxy);
d.a === d // true
```
> get拦截处理数组中负数下标
```js
function createArr(...ele) {
        // 解构创建一个数组
        let target = [...ele];

        // 拦截器
        let handler = {
            get(target, property) {
                // property 拦截的当前属性
                let index = Number(property);
                // 如果小于0
                if (index < 0) {
                    // 则用长度 + index
                    let proK = String(target.length + index);
                    // 最后返回Refect读取的值
                    return Reflect.get(target, proK);
                }
            }
        }

        return new Proxy(target, handler);
    }

    let arr = createArr(1, 2, 3);
    console.log(arr); // Proxy {0: 1, 1: 2, 2: 3}
    console.log(arr[-1]); // -1
```
> 通过get拦截的属性名创建节点，实现节点嵌套
```js

    let handler = {
        // 将拦截的属性作为节点名
        get(target, nodeName) {
            // attr 为元素上的属性
            // childs 为当前元素中的子元素
            return function (attr = {}, ...childs) {
                // 创建当前元素
                let ele = document.createElement(nodeName);
                // 遍历属性，设置在当前元素上
                Object.keys(attr).forEach((key => {
                    ele.setAttribute(key, attr[key]);
                }));

                // 遍历子元素集合
                for (let k of childs) {
                    // 如果为字符串则创建为文本节点
                    if (typeof(k) === 'string') {
                        k = document.createTextNode(k);
                    }
                    // 追加至当前元素中
                    ele.appendChild(k);
                }
                // 返回当前元素
                return ele;
            }
        }
    }

    const dom = new Proxy({}, handler);

    let ele = dom.ol(
        {type: 'A'},
        dom.li({}, '哈哈'),
        dom.li({}, '哈哈1'),
        dom.li({}, '哈哈2')
    );
    document.body.appendChild(ele);
```


2. set方法
    > set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为
        1. 目标对象、
        2. 属性名、
        3. 属性值
        4. Proxy 实例本身，其中最后一个参数可选

```js
    const handler = {
        set(target, property, value, prox) {
            console.log(target, property, value, prox);
            target[property] = value;
        }
    }

    let proxy = new Proxy({}, handler);
    proxy.a = 10;
```

3. apply()方法
    > 拦截函数的调用、call和apply操作
    > 参数
        1. 目标对象
        2. 上下文
        3. 目标对象的参数数组
```js
// 配置对象
let handler = {
    apply(target, ctx, arg) {
        console.log(arg); // [1, 2, 3]
        console.log(arguments); // 实参对象

        return Reflect.apply(...arguments);
    }
}

// 拦截对象
let proxy = new Proxy(function () {
    return 1;
}, handler);

// 调用
console.log(proxy(1, 2, 3)); // 1
```

4. has(target, prop)
    > 拦截propKey in proxy的操作，返回一个布尔值
5. deleteProperty(target, propKey)
    > 拦截delete proxy[propKey]的操作，返回一个布尔值
6. ownKeys(target)
    > 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性

7. getOwnPropertyDescriptor(target, propKey)
    > 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象

8. defineProperty(target, propKey, propDesc)
    > 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值

9. preventExtensions(target)
    > 拦截Object.preventExtensions(proxy)，返回一个布尔值
    > 目标对象不可扩展, Object.isExtensible(proxy)为false，proxy.preventExtensions才能返回true，否则会报错

10. getPrototypeOf(target)
    > 拦截Object.getPrototypeOf(proxy)，返回一个对象

11. isExtensible(target)
    > 拦截Object.isExtensible(proxy)，返回一个布尔值

12. setPrototypeOf(target, proto)
    > 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截

13. construct(target, args)
    > 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)







