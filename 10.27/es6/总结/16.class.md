ES6提供了更接近传统语言的写法，引入calss类的概念，作为对象的模板
通过class关键字，可以定义类

新的class写法可以让对象原型和写法更加清晰，更像面向对象编程的语法

类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行

类不存在变量提升


定义一个类
```js
    class Point {
        // 这里就是我们的构造函数
        constructor() {

            // this则指向的是实例
            this.x = x;
            this.y = y;
        }
    }

    // 可以看出来 其实是构造函数的另一种写法
    // 类的数据类型就是函数，类本身就指向构造函数
    typeof Point // "function"
    Point === Point.prototype.constructor // true


    // 使用的时候也是通过new命令，与构造函数是一致的
    let point = new Point(1, 2);


    // 构造函数中的prototype属性，在ES6的类上面依然存在
    // 类的所有方法都定义在类的prototype属性上面
    class Person {
        constructor() {

        }

        toValue() {

        }
    }
```

constructor方法
constructor是类的默认方法，通过new命令生成对象实例，自动调用该方法，一个类必须有constructor方法，如果没有显示的定义，也会自动创建一个空的constructor

constructor方法默认返回实例对象，完全可以指定返回另一个对象
```js
class Foo {
  constructor() {
    return Object.create(null);
  }
}

new Foo() instanceof Foo
// false
```

存值函数与取值函数
```js
class MyClass {
  constructor() {
    // ...
  }
  get prop() {
    return 'getter';
  }
  set prop(value) {
    console.log('setter: '+value);
  }
}

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// 'getter'
```

this指向问题

类中解构出来的方法会因为this指向报错
```js
class Logger {
  printName(name = 'there') {
    this.print(`Hello ${name}`);
  }

  print(text) {
    console.log(text);
  }
}

const logger = new Logger();
const { printName } = logger;
printName(); // TypeError: Cannot read property 'print' of undefined



// 解决方法 使用bind
class Logger {
  constructor() {
    this.printName = this.printName.bind(this);
  }

  // ...
}

// 解决方法，使用箭头函数
class Obj {
  constructor() {
    this.getThis = () => this;
  }
}

const myObj = new Obj();
myObj.getThis() === myObj // true

```


静态方法
直接通过类来调用，而不会被实例继承的方法，称之为静态方法
静态方法包含this关键字，这个this指的是类，而不是实例
静态方法可以与非静态方法重名
```js
class Foo {
  static classMethod() {
    return 'hello';
  }
}

Foo.classMethod() // 'hello'

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
```


静态方法，可以被子类继承
```js
class Foo {
  static classMethod() {
    return 'hello';
  }
}

class Bar extends Foo {
}

Bar.classMethod() // 'hello'
```

静态方法也是可以从super对象上调用的
```js
class Foo {
  static classMethod() {
    return 'hello';
  }
}

class Bar extends Foo {
  static classMethod() {
    return super.classMethod() + ', too';
  }
}

Bar.classMethod() // "hello, too"
```



静态属性
静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性

```js

// 老写法
class Foo {
}

Foo.prop = 1;
Foo.prop // 1

// 新写法
class MyClass {
  static myStaticProp = 42;

  constructor() {
    console.log(MyClass.myStaticProp); // 42
  }
}

```



calss的继承
Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多
```js
class Point {
}

class ColorPoint extends Point {
}
```

```js
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```

> 在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例
```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  }
}
```