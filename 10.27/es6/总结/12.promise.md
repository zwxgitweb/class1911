Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一


Promise的使用
> Promise是一个构造函数
    new Promise返回一个promise对象，接收一个函数作为参数，
    callback(resolve, reject)
```js
const promise = new Promise((resolve, reject) => {
    // 此时的代码依然是同步
    // 异步处理
    // 处理后的结果，=> resolve 或者 reject
});
```

Promise的状态
三种状态
    1. pending 等待
    2. fulfilled  完成
    3. rejected 失败

1. 当promise对象初始化状态 => pending
2. 当调用resolve(成功)  pending => fulfilled
3. 当调用reject(失败)  pending => rejected
注： 状态只能 pending => fulfilled/rejected ，修改后不能再变

Promise的方法

1. then方法: 接收两个参数： 一个成功回调函数，一个失败回调函数
> then方法是异步执行
```js
// onFulfilled 成功回调函数
// onRejected  失败回调函数
promise.then(onFulfilled, onRejected)
```

2. then中的两个函数
    resolve(成功) onFulfilled会被调用
    reject(失败) onRejected会被调用
```js
const promise = new Promise((resolve, reject) => {
        resolve('success'); // 将pending状态转为 fulfilled
        // reject('fail'); // 将pending状态转为 rejected
    });

    promise.then((res) => {
        // 成功 如果成功则不会执行onRejected的函数
        console.log(res);
    }, (res) => {
        // 失败 如果失败则不会执行onFulfilled的函数
        console.log(res);
    });

```

3. promise.catch(onRejected)
    > 在链式中捕获reject异常
```js
promise.catch((res) => {
    console.log(res);
})

// =>

promise.then(null, (res) => {
    console.log(res);
});

// =>
promise.then((res) => {
    // 成功 onFulfilled
    console.log(res);
}).catch((res) => {
    // 失败 onRejected
    console.log(res);
})

// 注： onRejected 不能捕获当前onFulfilled中的异常
```

4. promise chain (promise链式)
> promise.then方法每次调用 都返回一个新的promise对象 所以可以链式写法
```js
    function tA() {
        console.log('A');
    }

    function tB() {
        console.log('B');
    }

    function tErr() {
        console.log('err');
    }


    let promise = Promise.resolve();
    promise
        .then(tA)
        .then(tB)
        .catch(tErr)
```

5. Promise的静态方法
5.1 Promise.resolve返回一个fulfilled状态的promise对象
```js
Promise.resolve('hello').then(function(value){
    console.log(value);
});

Promise.resolve('hello');
// =>
const promise = new Promise(resolve => {
   resolve('hello');
});
```

5.2 Promise.reject返回一个rejected状态
```js
Promise.reject(24);
=>
new Promise((resolve, reject) => {
   reject(24);
});
```

5.3 Promise.all 接收一个promise对象数组为参数
全部为resolve才会调用 通常会用来处理 多个并行异步操作
```js
    const p1 = new Promise((resolve, reject) => {
        resolve(1);
    });
    const p2 = new Promise((resolve, reject) => {
        resolve(2);
    });
    const p3 = new Promise((resolve, reject) => {
        resolve(3);
    });

    Promise.all([p1, p2, p3]).then(data => {
        console.log(data); // [1, 2, 3] 结果顺序和promise实例数组顺序是一致的
    });
```

5.4 Promise.race 接收一个promise对象数组为参数, 返回率先改变状态promise的结果
```js
    function timer(delay) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(delay);
            }, delay)
        });
    }

    // 时间越短的，越早返回，则认为是率先改变状态的promise实例
    Promise.race([timer(20), timer(100), timer(5)]).then(data => {
        console.log(data)
    }, (err) => {
        console.log(err);
    });
```





